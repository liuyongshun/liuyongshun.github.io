<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>promise | 七月</title>
  <meta name="baidu-site-verification" content="vdMfpFtVYF">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="Smiple, 简, jian, 简博客">
  <meta name="description" content="一、 Promise处理异步1.1 基本用法123456789const promise = new Promise(function(resolve, reject) &amp;#123;  setTimeout(() =&amp;gt; &amp;#123;    if (/*成功*/)&amp;#123;      resolve(value);    &amp;#125; else &amp;#123;      reject(erro">
<meta name="keywords" content="es6">
<meta property="og:type" content="article">
<meta property="og:title" content="promise">
<meta property="og:url" content="http://liuyongshun.github.io/2018/09/02/ES6-promise/index.html">
<meta property="og:site_name" content="七月">
<meta property="og:description" content="一、 Promise处理异步1.1 基本用法123456789const promise = new Promise(function(resolve, reject) &amp;#123;  setTimeout(() =&amp;gt; &amp;#123;    if (/*成功*/)&amp;#123;      resolve(value);    &amp;#125; else &amp;#123;      reject(erro">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190331114725316.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXlvbmdzaHVuMg==,size_16,color_FFFFFF,t_70">
<meta property="og:updated_time" content="2020-09-19T09:14:17.328Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="promise">
<meta name="twitter:description" content="一、 Promise处理异步1.1 基本用法123456789const promise = new Promise(function(resolve, reject) &amp;#123;  setTimeout(() =&amp;gt; &amp;#123;    if (/*成功*/)&amp;#123;      resolve(value);    &amp;#125; else &amp;#123;      reject(erro">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20190331114725316.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXlvbmdzaHVuMg==,size_16,color_FFFFFF,t_70">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

  <script></script>
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">七月</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">是七月呀</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/link">链接</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://liuyongshun.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-ES6-promise" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/02/ES6-promise/" class="article-date">
  <time datetime="2018-09-02T14:29:17.000Z" itemprop="datePublished">2018-09-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ES6/">ES6</a>►<a class="article-category-link" href="/categories/ES6/promise/">promise</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      promise
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一、-Promise处理异步"><a href="#一、-Promise处理异步" class="headerlink" title="一、 Promise处理异步"></a>一、 Promise处理异步</h3><h4 id="1-1-基本用法"><a href="#1-1-基本用法" class="headerlink" title="1.1 基本用法"></a>1.1 基本用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    if (/*成功*/)&#123;</span><br><span class="line">      resolve(value);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>Promise <strong>新建后就会立即执行</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(111);</span><br><span class="line">    resolve(444)</span><br><span class="line">    console.log(222);</span><br><span class="line">  &#125;);</span><br><span class="line">p.then((value) =&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(333)</span><br><span class="line"></span><br><span class="line">// 输出顺序</span><br><span class="line">111</span><br><span class="line">222</span><br><span class="line">333</span><br><span class="line">444</span><br></pre></td></tr></table></figure>
<ul>
<li>异步加载图片</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function loadImageAsync (url) &#123;</span><br><span class="line">  return new Promise(function (resolve, reject) &#123;</span><br><span class="line">    const image = new Image()</span><br><span class="line">    // 加载成功后resolve</span><br><span class="line">    image.onload = function() &#123;</span><br><span class="line">      resolve(image)</span><br><span class="line">    &#125;</span><br><span class="line">    image.onerror = function() &#123;</span><br><span class="line">      reject(new Error(&apos;Could not load image at &apos; + url))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    image.src = url</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-执行情况"><a href="#1-2-执行情况" class="headerlink" title="1.2 执行情况"></a>1.2 执行情况</h4><ul>
<li><p>p1 3秒之后变为 rejected</p>
</li>
<li><p>p2 1秒之后变为 resolve， 值为 p1，p2返回的是另一个 Promise，导致p2自己的状态无效化，由p1的状态决定p2的状态</p>
</li>
<li><p>因此后面的then语句都是针对 p1。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  setTimeout(() =&gt; reject(new Error(&apos;fail&apos;)), 3000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const p2 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  setTimeout(() =&gt; resolve(p1), 1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .then(result =&gt; console.log(result))</span><br><span class="line">  .catch(error =&gt; console.log(error))</span><br></pre></td></tr></table></figure>
<p><strong>1.2.2</strong> Promise 在resolve后，再抛出错误，不会被捕获，因为 Promise 的状态一旦改变，就永久保持该状态</p>
<ul>
<li>resolve或reject后面的代码依然可以执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  resolve(&apos;ok&apos;);</span><br><span class="line">  console.log(&apos;ffff&apos;)</span><br><span class="line">  throw new Error(&apos;test&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(function(value) &#123; console.log(value) &#125;)</span><br><span class="line">  .catch(function(error) &#123; console.log(error) &#125;);</span><br></pre></td></tr></table></figure>
<p><strong>1.2.3</strong> then的参数不是函数，后面链式调用依然可以正常执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const p1 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  resolve(1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(3)</span><br><span class="line">  .then((result) =&gt; &#123;</span><br><span class="line">    console.log(result, &quot;result&quot;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch((error) =&gt; &#123;</span><br><span class="line">    console.log(error, &quot;error&quot;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p><strong>1.2.4</strong> 当 Promise 更新后，后面在调用依然可以拿到最新的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var promise1 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  resolve(&quot;promise 的resolve&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise1.then((res) =&gt; &#123;</span><br><span class="line">  console.log(res, &quot;1&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  promise1.then((res) =&gt; &#123;</span><br><span class="line">    console.log(res, &quot;2&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, 500);</span><br></pre></td></tr></table></figure>
<h4 id="1-3-Promise-all"><a href="#1-3-Promise-all" class="headerlink" title="1.3 Promise.all()"></a>1.3 Promise.all()</h4><ul>
<li><p>PromisePromise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例</p>
</li>
<li><p>只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组</p>
</li>
<li><p>只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值</p>
</li>
<li><p>const p = Promise.all([p1, p2, p3])</p>
</li>
</ul>
<h4 id="1-4-有时需要将现有对象转为-Promise-对象"><a href="#1-4-有时需要将现有对象转为-Promise-对象" class="headerlink" title="1.4 有时需要将现有对象转为 Promise 对象"></a>1.4 有时需要将现有对象转为 Promise 对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve()</span><br><span class="line">Promise.resolve(&apos;foo&apos;)</span><br><span class="line"></span><br><span class="line">// 等价于</span><br><span class="line">new Promise(resolve =&gt; resolve(&apos;foo&apos;))</span><br></pre></td></tr></table></figure>
<h4 id="1-5-错误处理"><a href="#1-5-错误处理" class="headerlink" title="1.5 错误处理"></a>1.5 错误处理</h4><ul>
<li>then有两个参数，第一个是成功的回调，第二个是错误的回调</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 错误处理推荐</span><br><span class="line">const promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  throw new Error(&apos;test&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(function(error) &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 不推荐这种</span><br><span class="line">const promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    throw new Error(&apos;test&apos;);</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(function(error) &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 也不推荐第二个参数</span><br><span class="line">promise.then(function (res) &#123;&#125;, function (err) &#123;&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="1-6-finally"><a href="#1-6-finally" class="headerlink" title="1.6 finally()"></a>1.6 finally()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.finally()  finally方法不管 Promise 对象最后状态如何，都会执行</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">.then(result =&gt; &#123;···&#125;)</span><br><span class="line">.catch(error =&gt; &#123;···&#125;)</span><br><span class="line">.finally(() =&gt; &#123;···&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="1-7-Promise-链式调用"><a href="#1-7-Promise-链式调用" class="headerlink" title="1.7 Promise 链式调用"></a>1.7 Promise 链式调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">var promise1 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  resolve(&apos;第一个promise 的resolve&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise1.then(res =&gt; &#123;</span><br><span class="line">  // promise then的第一参数是成功时执行，第二个是失败时执行</span><br><span class="line">  console.log(res, &apos;1&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(res =&gt; &#123;</span><br><span class="line">  // 多个then连续调用时，只有第一个then能拿到resolve的值，后续的只是会被执行但是无法获取resolve的值。</span><br><span class="line">  console.log(res, &apos;2&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(res =&gt; &#123;</span><br><span class="line">  console.log(res, &apos;3&apos;)</span><br><span class="line">  // then内返回一个Promise对象时，后续的then都是依赖于返回的Promise 对象</span><br><span class="line">  return new Promise(function (resolve, reject) &#123;</span><br><span class="line">    setTimeout(_ =&gt; &#123;</span><br><span class="line">      resolve(&apos;第二个promise 的resolve&apos;)</span><br><span class="line">    &#125;, 3000)</span><br><span class="line">    // b(new Error(&apos;zzzz&apos;))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(res =&gt; &#123;</span><br><span class="line">  // 该then取到的事上面返回的Promise的resolve的值。</span><br><span class="line">  console.log(res, &apos;4&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(res =&gt; &#123;</span><br><span class="line">  console.log(res, &apos;5&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(res =&gt; &#123;</span><br><span class="line">  console.log(res, &apos;error&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="1-8-Promise-和-setTimeout-宏任务和微任务"><a href="#1-8-Promise-和-setTimeout-宏任务和微任务" class="headerlink" title="1.8 Promise 和 setTimeout (宏任务和微任务)"></a>1.8 Promise 和 setTimeout (宏任务和微任务)</h4><ul>
<li><p>一个线程中，事件循环是唯一的，但是任务队列可以拥有多个</p>
</li>
<li><p>任务队列又分为macro-task（宏任务）与micro-task（微任务），在最新标准中，它们被分别称为task与jobs</p>
</li>
<li><p>macro-task大概包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering</p>
</li>
<li><p>micro-task大概包括: process.nextTick, Promise, MutationObserver(html5新特性)</p>
</li>
</ul>
<ol>
<li><p>执行栈内执行上下文的同步任务按序执行，执行完即退栈，而当异步任务执行时，该异步任务进入等待状态（不入栈），同时通知线程：当触发该事件时（或该异步操作响应返回时），需向消息队列插入一个事件消息</p>
</li>
<li><p>当事件触发或响应返回时，线程向消息队列插入该事件消息（包含事件及回调）</p>
</li>
<li><p>当栈内同步任务执行完毕后，线程从消息队列取出一个事件消息，其对应异步任务（函数）入栈，执行回调函数，如果未绑定回调，这个消息会被丢弃，执行完任务后退栈</p>
</li>
<li><p>当线程空闲（即执行栈清空）时继续拉取消息队列下一轮消息，首先去拉取micro-task（微任务），直到所有执行完毕，然后循环再次从macro-task（宏任务）开始，这样一直循环下去</p>
</li>
<li><p>主线程不断重复上面的第4步</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20190331114725316.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXlvbmdzaHVuMg==,size_16,color_FFFFFF,t_70" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;timeout1&apos;);</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&apos;timeout1_then&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">new Promise((a) =&gt; &#123;</span><br><span class="line">  a(&apos;ffff&apos;)</span><br><span class="line">&#125;).then(_ =&gt; &#123;</span><br><span class="line">  console.log(&quot;promise outer&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">// 输出顺序</span><br><span class="line">promise outer</span><br><span class="line">timeout1</span><br><span class="line">timeout1_then</span><br></pre></td></tr></table></figure>
<h3 id="Promise-源码实现"><a href="#Promise-源码实现" class="headerlink" title="Promise 源码实现"></a>Promise 源码实现</h3><h4 id="分析Promise"><a href="#分析Promise" class="headerlink" title="分析Promise"></a>分析Promise</h4><p>从上面的基本使用，我们对 Promise 有大概的了解</p>
<ul>
<li><p>Promise的构造方法接收一个executor()，在new Promise()时就立刻执行这个executor回调</p>
</li>
<li><p>resolve 成功执行then，reject 失败 执行catch</p>
</li>
<li><p>拥有 <code>then, catch, resolve, all, finally</code>等方法</p>
</li>
<li><p>Promise 变为成功或失败后，状态无法在更改 resolve 后在 rejected 不会被捕获（Promise A+ 规定必须有三个状态 pending，fulfilled，rejected）<a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise A+</a></p>
</li>
<li><p>Promise 可以链式调用，而且then, catch, finally 等都是异步执行</p>
</li>
<li><p>then(onFulfilled, onRejected) then 接收两个可选参数，一个成功回调，一个失败回调</p>
</li>
<li><p>Promise本质是一个状态机，且状态只能为以下三种：Pending（等待态）、Fulfilled（执行态）、Rejected（拒绝态），状态的变更是单向的，只能从Pending -&gt; Fulfilled 或 Pending -&gt; Rejected，状态变更不可逆</p>
</li>
<li><p>我们可以直接调用 <code>Promise.all, Promise.reject, Promise.resolve</code> 但是不能 new 之后调用，说明这三个方法是静态方法，不会被实例继承</p>
</li>
</ul>
<p>从上面我们大概构造出一个轮廓</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class CPromise &#123;</span><br><span class="line">  #status;</span><br><span class="line">  constructor(executeFn) &#123;</span><br><span class="line">    this.#status = &quot;pending&quot;;</span><br><span class="line">    const resolve = () =&gt; &#123;&#125;;</span><br><span class="line">    const reject = () =&gt; &#123;&#125;;</span><br><span class="line">    executeFn(resolve, reject);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // then 方法</span><br><span class="line">  then(resFn, rejFn) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  // catch 方法</span><br><span class="line">  catch(rejectFn) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  // finally 方法</span><br><span class="line">  finally(callback) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  // 静态的resolve 方法</span><br><span class="line">  static resolve(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  // 静态的reject 方法</span><br><span class="line">  static reject(reason) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  // 静态all 方法</span><br><span class="line">  static all(promiseArr) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const p = new CPromise((res, rej) =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="实现then"><a href="#实现then" class="headerlink" title="实现then"></a>实现then</h4><p><strong>看一段代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var promise1 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  resolve(&quot;promise 的resolve&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise1</span><br><span class="line">  .then((res) =&gt; &#123;</span><br><span class="line">    console.log(res, &quot;1&quot;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then((res) =&gt; &#123;</span><br><span class="line">    console.log(res, &quot;3&quot;);</span><br><span class="line">    return 4</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.log(res, &quot;4&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">promise1.then((res) =&gt; &#123;</span><br><span class="line">  console.log(res, &quot;2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">promise 的resolve 1 </span><br><span class="line">promise 的resolve 2 </span><br><span class="line">undefined  &quot;3&quot; </span><br><span class="line">4  &quot;4&quot;</span><br></pre></td></tr></table></figure>
<p>根据上面分析下面四点</p>
<ul>
<li><p>异步或者同步调用的 resolve 其值要传递给then的回调第一个参数， reject 值要传递个catch的回调第一个参数</p>
</li>
<li><p>无论调用多少个非链式调用的 then 或 catch 都能正确的取到 resolve 或 reject 传递的值</p>
</li>
<li><p>链式调用时，第二次及以后then无法得到 resolve 的值</p>
</li>
<li><p>then 和 catch 本身接收的都是函数参数</p>
</li>
<li><p>then可以链式调用并能够拿到上一个then的返回值，说明then返回的还是Promise对象，并且值能正确传递过来</p>
</li>
</ul>
<p>分析上面四个特点，我们可以得知当 resolve 和 reject 时，通知 then 或 catch 接收的参数（是一个函数）调用并更新参数。而这种实现就是常听到的观察者模式。</p>
<p><strong>观察者模式</strong></p>
<p>定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使它们能够自动更新自己</p>
<ul>
<li><p>一： resolve 或 reject</p>
</li>
<li><p>多： 每个promise.then的参数匿名函数，then方法执行就会收集订阅（该匿名函数）</p>
</li>
<li><p>resolve 或 reject 发生改变，更新调用所有的订阅（函数）并传递更新后的值</p>
</li>
</ul>
<p><strong>使用场景:</strong> 当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，应考虑观察者模式</p>
<p><strong>经过上面的分析，我们大概写出如下代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">class CPromise &#123;</span><br><span class="line">  #resolveQueue;</span><br><span class="line">  #rejectQueue;</span><br><span class="line">  constructor(executeFn) &#123;</span><br><span class="line">    // 接收订阅的数组，其实是每个then方法接收的函数入参数</span><br><span class="line">    this.#resolveQueue = [];</span><br><span class="line">    this.#rejectQueue = [];</span><br><span class="line">    // 当 resolve 或 reject 时，会触发所有的订阅更新</span><br><span class="line">    const resolve = (val) =&gt; &#123;</span><br><span class="line">      while (this.#resolveQueue.length) &#123;</span><br><span class="line">        const callback = this.#resolveQueue.shift();</span><br><span class="line">        callback(val);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    const reject = (val) =&gt; &#123;</span><br><span class="line">      while (this.#rejectQueue.length) &#123;</span><br><span class="line">        const callback = this.#rejectQueue.shift();</span><br><span class="line">        callback(val);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    executeFn(resolve, reject);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(resFn, rejFn) &#123;</span><br><span class="line">    return new CPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">      const fulfilledFn = (value) =&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          // 获取then的返回值</span><br><span class="line">          let x = resFn(value);</span><br><span class="line">          // 如果是Promise对象，执行一次新的then添加到订阅队列，如果不是，则直接解析</span><br><span class="line">          // 这段代码可以仔细思考一下，如果你then返回的Promise对象，后面链式调用的then其实你新实例化对象的then方法了。</span><br><span class="line">          // 如果then返回的是新的Promise对象A，这里首先 x instanceof CPromise 为 true， 并执行一次你返回Promise对象A的then收集到订阅队列</span><br><span class="line">          // 当你Promise对象A的resolve执行时，执行队列里的函数发布更新，而更新的函数就是当前then方法内自带的实例化Promise的resolve。</span><br><span class="line">          x instanceof CPromise ? x.then(resolve, reject) : resolve(x);</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">          reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      this.#resolveQueue.push(fulfilledFn);</span><br><span class="line"></span><br><span class="line">      const rejectedFn = (error) =&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          let x = rejFn(error);</span><br><span class="line">          x instanceof CPromise ? x.then(resolve, reject) : reject(x);</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">          reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      this.#rejectQueue.push(rejectedFn);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 使用我们自己的CPromise</span><br><span class="line"></span><br><span class="line">const p = new CPromise((res, rej) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    res(3);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then((res) =&gt; &#123;</span><br><span class="line">  console.log(res, &quot;位置1&quot;);</span><br><span class="line">  return 8;</span><br><span class="line">&#125;)</span><br><span class="line">  .then((res) =&gt; &#123;</span><br><span class="line">    console.log(res, &quot;位置1-1&quot;);</span><br><span class="line">    return new CPromise((ress, rejj) =&gt; &#123;</span><br><span class="line">      // 注意这里，我加了异步，如果没有则拿不到7777的值</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        ress(7777);</span><br><span class="line">      &#125;, 1000);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then((res) =&gt; &#123;</span><br><span class="line">    console.log(res, &quot;位置1-2&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">p.then((res) =&gt; &#123;</span><br><span class="line">  console.log(res, &quot;位置2&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>上面代码，初步来看结果已经符合 Promise 的使用表现了，不过还有两个问题</strong></p>
<ul>
<li><p>同步逻辑没处理，如果同步执行，你会发现resolve和reject在then之前执行。还没收集到订阅就触发更新了</p>
</li>
<li><p>Promise的状态转换没处理，reject/resolve 后不可 resolve/reject</p>
</li>
</ul>
<p><strong>同步逻辑处理</strong></p>
<ul>
<li><p>观察上面代码的这段内容可以知道，如果我在new CPromise 时，同步执行 resolve 方法，此时还没有调用then方法，订阅队列里根本没有订阅内容，所以也不会有数据更新。</p>
</li>
<li><p>但是真正的Promise，不管你同步还是异步，它都能正确更新，而且无需我们resolve时加 setTimeout 处理。</p>
</li>
<li><p>因此，我们可以对 resolve 和 reject 方法进行处理，把更新订阅放到事件队列的最后面执行</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const resolve = (val) =&gt; &#123;</span><br><span class="line">  // 同步 resolve，会在then方法执行前出发，由于then还没有触发，订阅队列内并没有收集到订阅</span><br><span class="line">  while (this.#resolveQueue.length) &#123;</span><br><span class="line">    const callback = this.#resolveQueue.shift();</span><br><span class="line">    callback(val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>变成如下代码，reject 同理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const resolve = (val) =&gt; &#123;</span><br><span class="line">  const exFn = () =&gt; &#123;</span><br><span class="line">    while (this.#resolveQueue.length) &#123;</span><br><span class="line">      const callback = this.#resolveQueue.shift();</span><br><span class="line">      callback(val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  // 这里这是用setTimeout添加到宏任务队列</span><br><span class="line">  setTimeout(exFn);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>状态处理</strong></p>
<ul>
<li><p>上面 1.2 执行情况中，当我 resolve 后，即使在 reject ，catch 也不会捕获到错误</p>
</li>
<li><p>当Promise的状态从 pending 变成 fulfilled 或 rejected 后，就不会在发生改变</p>
</li>
<li><p>另外即使 then的参数不是函数，链式调用依然不会受影响</p>
</li>
<li><p>当 Promise 更新后，后面在调用then依然可以拿到最新的值</p>
</li>
</ul>
<p>为了方便测试比较，我们先把 catch 实现，catch和then的第二个参数是一样的，接收一个函数，函数的参数是捕获的错误，因此catch实现起来就比较简单了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">catch(rejectFn) &#123;</span><br><span class="line">  return this.then(undefined, rejectFn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑上面then的非函数情况，和后续链式调用的正常使用，我们对 then 做进一步处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">class CPromise &#123;</span><br><span class="line">  #resolveQueue;</span><br><span class="line">  #rejectQueue;</span><br><span class="line">  constructor(executeFn) &#123;</span><br><span class="line">    this.#resolveQueue = [];</span><br><span class="line">    this.#rejectQueue = [];</span><br><span class="line">    const resolve = (val) =&gt; &#123;</span><br><span class="line">      const exFn = () =&gt; &#123;</span><br><span class="line">        while (this.#resolveQueue.length) &#123;</span><br><span class="line">          const callback = this.#resolveQueue.shift();</span><br><span class="line">          callback(val);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      setTimeout(exFn);</span><br><span class="line">    &#125;;</span><br><span class="line">    const reject = (val) =&gt; &#123;</span><br><span class="line">      const exFn = () =&gt; &#123;</span><br><span class="line">        while (this.#rejectQueue.length) &#123;</span><br><span class="line">          const callback = this.#rejectQueue.shift();</span><br><span class="line">          callback(val);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      setTimeout(exFn);</span><br><span class="line">    &#125;;</span><br><span class="line">    executeFn(resolve, reject);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(resFn, rejFn) &#123;</span><br><span class="line">    // 不是函数，容错处理，并保证链式调用的正常</span><br><span class="line">    if (typeof resFn !== &quot;function&quot;) &#123;</span><br><span class="line">      resFn = (value) =&gt; value;</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof rejFn !== &quot;function&quot;) &#123;</span><br><span class="line">      rejFn = (errors) =&gt; errors;</span><br><span class="line">    &#125;</span><br><span class="line">    return new CPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">      const fulfilledFn = (value) =&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          let x = resFn(value);</span><br><span class="line">          x instanceof CPromise ? x.then(resolve, reject) : resolve(x);</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">          reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      const rejectedFn = (error) =&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          let x = rejFn(error);</span><br><span class="line">          x instanceof CPromise ? x.then(resolve, reject) : reject(x);</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">          reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      this.#resolveQueue.push(fulfilledFn);</span><br><span class="line">      this.#rejectQueue.push(rejectedFn);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // catch 实现</span><br><span class="line">  catch(rejectFn) &#123;</span><br><span class="line">    return this.then(undefined, rejectFn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用我们实现的 CPromise 去执行下面代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const p1 = new CPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(1);</span><br><span class="line">  reject(8);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(3)</span><br><span class="line">  .then((result) =&gt; &#123;</span><br><span class="line">    console.log(result, &quot;result&quot;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch((error) =&gt; &#123;</span><br><span class="line">    console.log(error, &quot;error&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">1 &quot;result&quot; </span><br><span class="line">8 &quot;error&quot;</span><br></pre></td></tr></table></figure>
<p>很明显我们实现了，then入参非函数也能保证链式调用正常使用，但是 resolve 之后，reject 结果依然被 catch 捕获了，很明显这是不符合 Promise 的特性的，为此我们还需要处理状态变更</p>
<p>pending -&gt; fulfilled</p>
<p>pending -&gt; rejected</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">class CPromise &#123;</span><br><span class="line">  #status;</span><br><span class="line">  #resolveQueue;</span><br><span class="line">  #rejectQueue;</span><br><span class="line">  #value;</span><br><span class="line">  constructor(executeFn) &#123;</span><br><span class="line">    this.#status = &quot;pending&quot;;</span><br><span class="line">    this.#resolveQueue = [];</span><br><span class="line">    this.#rejectQueue = [];</span><br><span class="line">    this.#value = undefined;</span><br><span class="line">    const resolve = (val) =&gt; &#123;</span><br><span class="line">      const exFn = () =&gt; &#123;</span><br><span class="line">        if (this.#status !== &quot;pending&quot;) return;</span><br><span class="line">        this.#status = &quot;fulfilled&quot;;</span><br><span class="line">        while (this.#resolveQueue.length) &#123;</span><br><span class="line">          const callback = this.#resolveQueue.shift();</span><br><span class="line">          callback(val);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      setTimeout(exFn);</span><br><span class="line">    &#125;;</span><br><span class="line">    const reject = (val) =&gt; &#123;</span><br><span class="line">      const exFn = () =&gt; &#123;</span><br><span class="line">        if (this.#status !== &quot;pending&quot;) return;</span><br><span class="line">        this.#status = &quot;rejected&quot;;</span><br><span class="line">        while (this.#rejectQueue.length) &#123;</span><br><span class="line">          const callback = this.#rejectQueue.shift();</span><br><span class="line">          callback(val);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      setTimeout(exFn);</span><br><span class="line">    &#125;;</span><br><span class="line">    executeFn(resolve, reject);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(resFn, rejFn) &#123;</span><br><span class="line">    if (typeof resFn !== &quot;function&quot;) &#123;</span><br><span class="line">      resFn = (value) =&gt; value;</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof rejFn !== &quot;function&quot;) &#123;</span><br><span class="line">      rejFn = (errors) =&gt; errors;</span><br><span class="line">    &#125;</span><br><span class="line">    return new CPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">      const fulfilledFn = (value) =&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          let x = resFn(value);</span><br><span class="line">          x instanceof CPromise ? x.then(resolve, reject) : resolve(x);</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">          reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      const rejectedFn = (error) =&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          let x = rejFn(error);</span><br><span class="line">          x instanceof CPromise ? x.then(resolve, reject) : reject(x);</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">          reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      switch (this.#status) &#123;</span><br><span class="line">        case &quot;pending&quot;:</span><br><span class="line">          this.#resolveQueue.push(fulfilledFn);</span><br><span class="line">          this.#rejectQueue.push(rejectedFn);</span><br><span class="line">          break;</span><br><span class="line">        case &quot;fulfilled&quot;:</span><br><span class="line">          fulfilledFn(this.#value);</span><br><span class="line">          break;</span><br><span class="line">        case &quot;rejected&quot;:</span><br><span class="line">          rejectedFn(this.#value);</span><br><span class="line">          break;</span><br><span class="line">        default:</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //catch</span><br><span class="line">  catch(rejectFn) &#123;</span><br><span class="line">    return this.then(undefined, rejectFn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里我们常用的 Promise 已经完成了。then 和 catch 以及一些表现形式都符合一个真正的Promise。接下来完善其他方法。</p>
<p><strong>Promise.resolve</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static resolve(value) &#123;</span><br><span class="line">  if (value instanceof CPromise) return value;</span><br><span class="line">  return new CPromise((resolve) =&gt; resolve(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Promise.reject</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static reject(reason) &#123;</span><br><span class="line">  return new CPromise((resolve, reject) =&gt; reject(reason));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Promise.finally</strong></p>
<p>finally()方法返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。在finally之后，还可以继续then。并且会将值原封不动的传递给后面的then</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">finally(callback) &#123;</span><br><span class="line"> return this.then(</span><br><span class="line">   (value) =&gt; CPromise.resolve(callback()).then(() =&gt; value),</span><br><span class="line">   (reason) =&gt;</span><br><span class="line">     CPromise.resolve(callback()).then(() =&gt; &#123;</span><br><span class="line">       throw reason;</span><br><span class="line">     &#125;)</span><br><span class="line"> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Promise.all</strong></p>
<ul>
<li><p>Promise.all 方法返回一个 Promise 实例</p>
</li>
<li><p>所有的 promise 都 resolve 或参数中不包含 promise 时回调完成</p>
</li>
<li><p>如果有一个 rejected，此实例回调失败，失败原因的是第一个失败 promise 的结果</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static all(pro) &#123;</span><br><span class="line">  let index = 0;</span><br><span class="line">  let result = [];</span><br><span class="line">  return new CPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">    pro.forEach((p, i) =&gt; &#123;</span><br><span class="line">      CPromise.resolve(p).then(</span><br><span class="line">        (val) =&gt; &#123;</span><br><span class="line">          index++;</span><br><span class="line">          result[i] = val;</span><br><span class="line">          if (index === pro.length) &#123;</span><br><span class="line">            resolve(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        (err) =&gt; &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/liuyongshun/all-demo/tree/master/Promise" target="_blank" rel="noopener">完整代码</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuyongshun.github.io/2018/09/02/ES6-promise/" data-id="ckh18y6dj00b1nmcuxr16esma" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/04/08/tool-mac/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          mac
        
      </div>
    </a>
  
  
    <a href="/2018/09/02/ES6-generator/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">generator</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/DEV/">DEV</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/DEV/trouble/">trouble</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/">ES6</a><span class="category-list-count">14</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/array/">array</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/async/">async</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/class/">class</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/decorate/">decorate</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/export-import/">export&import</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/fuction/">fuction</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/generator/">generator</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/object/">object</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/promise/">promise</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/proxy/">proxy</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/reflect/">reflect</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/set-map/">set&map</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/string/">string</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/variable-deconstruction/">variable&deconstruction</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/FLUTTER/">FLUTTER</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/FLUTTER/dart/">dart</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/FLUTTER/env/">env</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/H5/">H5</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/H5/h5-history/">h5 history</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/H5/h5-video/">h5 video</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTML-CSS/">HTML & CSS</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/HTML-CSS/HTML-CSS/">HTML & CSS</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/HYBRID/">HYBRID</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/HYBRID/hybrid/">hybrid</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/">JS</a><span class="category-list-count">6</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JS/FP/">FP</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/algorithm/">algorithm</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/algorithm2/">algorithm2</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/base/">base</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/data-constructor/">data constructor</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/principle/">principle</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/NODE/">NODE</a><span class="category-list-count">11</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/NODE/express/">express</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NODE/module/">module</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NODE/mongo/">mongo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NODE/mongoCommand/">mongoCommand</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NODE/mongoOprate/">mongoOprate</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NODE/mongoodb/">mongoodb</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NODE/node-api/">node api</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NODE/node-buffer/">node buffer</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NODE/node-eventloop/">node eventloop</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NODE/node-stream/">node stream</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NODE/variable/">variable</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/NPM/">NPM</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/NPM/cli/">cli</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NPM/npm-package/">npm package</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/PLAY/">PLAY</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/PLAY/photo/">photo</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/REACT/">REACT</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/REACT/hook/">hook</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/REACT/react/">react</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/REACT/redux/">redux</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/TOOL/">TOOL</a><span class="category-list-count">10</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/TOOL/chrome/">chrome</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TOOL/chrome-perf/">chrome-perf</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TOOL/debug/">debug</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TOOL/frequently/">frequently</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TOOL/git/">git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TOOL/mac/">mac</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TOOL/nginx/">nginx</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TOOL/vscode-plugin/">vscode plugin</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/TS/">TS</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/TS/ts-base/">ts base</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/VUE/">VUE</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/VUE/principle/">principle</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/VUE/vueRouter/">vueRouter</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/">WEB</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/web/">web</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEBPACK/">WEBPACK</a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/WEBPACK/ast/">ast</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEBPACK/plugin/">plugin</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEBPACK/webpack-react/">webpack-react</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEBPACK/webpackDescription/">webpackDescription</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEEX/">WEEX</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/WEEX/use/">use</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEEX/weex/">weex</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/cache/">cache</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/cache/cache/">cache</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/performance/">performance</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/performance/performance/">performance</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/performance/time-slice/">time slice</a><span class="category-list-count">1</span></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/DEV/">DEV</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6/">ES6</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/H5/">H5</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/">HTML</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HYBRID/">HYBRID</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/">JS</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NODE/">NODE</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NPM/">NPM</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/REACT/">REACT</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TS/">TS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cli/">cli</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/">es6</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flutter/">flutter</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mac/">mac</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/performance/">performance</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/play/">play</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tool/">tool</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/variable/">variable</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vscode/">vscode</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/">webpack</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/weex/">weex</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/DEV/" style="font-size: 10px;">DEV</a> <a href="/tags/ES6/" style="font-size: 11.43px;">ES6</a> <a href="/tags/H5/" style="font-size: 11.43px;">H5</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/HYBRID/" style="font-size: 10px;">HYBRID</a> <a href="/tags/JS/" style="font-size: 17.14px;">JS</a> <a href="/tags/NODE/" style="font-size: 10px;">NODE</a> <a href="/tags/NPM/" style="font-size: 11.43px;">NPM</a> <a href="/tags/REACT/" style="font-size: 12.86px;">REACT</a> <a href="/tags/TS/" style="font-size: 10px;">TS</a> <a href="/tags/cli/" style="font-size: 10px;">cli</a> <a href="/tags/es6/" style="font-size: 20px;">es6</a> <a href="/tags/flutter/" style="font-size: 11.43px;">flutter</a> <a href="/tags/mac/" style="font-size: 10px;">mac</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/node/" style="font-size: 18.57px;">node</a> <a href="/tags/performance/" style="font-size: 12.86px;">performance</a> <a href="/tags/play/" style="font-size: 10px;">play</a> <a href="/tags/tool/" style="font-size: 15.71px;">tool</a> <a href="/tags/variable/" style="font-size: 10px;">variable</a> <a href="/tags/vscode/" style="font-size: 10px;">vscode</a> <a href="/tags/vue/" style="font-size: 11.43px;">vue</a> <a href="/tags/webpack/" style="font-size: 14.29px;">webpack</a> <a href="/tags/weex/" style="font-size: 11.43px;">weex</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">4</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/07/02/node-cache/">cache</a>
          </li>
        
          <li>
            <a href="/2020/10/11/webpack-react/">webpack react</a>
          </li>
        
          <li>
            <a href="/2020/08/11/ts-base/">ts base</a>
          </li>
        
          <li>
            <a href="/2020/07/20/performance-time-split/">time slice</a>
          </li>
        
          <li>
            <a href="/2020/06/19/AST/">AST</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <ul class="hobby-outer">
      <li class="hobby-item"><a href="http://blog.csdn.net/liuyongshun2/article">CSDN</a></li>
      <li class="hobby-item"><a href="https://github.com/liuyongshun">GITHUB</a></li>
    </ul>
    <div id="footer-info" class="inner">
      &copy; 2020 cheat&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1274642270'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1274642270%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script>



    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/link" class="mobile-nav-link">链接</a>
  
</nav>
    

<script src="https://code.jquery.com/jquery-latest.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<div id="totop">
  <a title="javascript:;">返回<br>顶部</a>
</div>
<script src="/js/totop.js"></script>

  </div>
</body>
</html>